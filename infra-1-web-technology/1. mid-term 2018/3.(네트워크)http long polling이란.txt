롱폴링이란? 
롱폴링은 HTTP/1.1에 없는 푸시 메커니즘을 에뮬레이트합니다.
클라이언트가 HTTP 요청을 보냅니다. 서버가 요청을 열린 상태로 유지
HTTP 응답을 보내기 전에 새 데이터를 사용할 수 있을 때까지 일단
응답이 전송되면 클라이언트는 즉시 다른 HTTP 요청을 보냅니다.
열린 상태로 유지되는 것입니다.



<해설>
HTML5 WebSocket은 웹에서 양 방향 통신을 지원하며, 그에 따른 실시간 서비스를 구현하기에 적합한 기술입니다.
또한, HTTP 실시간 통신 방식(COMET)인 폴링(Polling), 롱폴링(Long Polling), 스트리밍(Streaming) 방식보다 월등한 성능 차이를 보여줍니다.
기존 HTTP 실시간 통신 방식(COMET):
1. 폴링(Polling) 방식:
- 브라우저가 일정한 주기로 HTTP 요청을 보내는 방식입니다.
보통 실시간 데이터의 업데이트 주기는 예측하기 어려우므로, 그에 따른 불필요한 서버 및 네트웍 부하가 늘어납니다.
즉, 불필요한 서버 요청이 다수 생긴다는 말입니다.
2. 롱폴링(Long Polling) 방식:
- HTTP 요청 시 서버는 해당 요청을 일정 시간 동안 대기 시킵니다. 만약, 대기 시간 안에 데이터가 업데이트되었다면, 그 즉시 클라이언트에게 응답을 보내고 전달받은 데이터를 처리 후 서버로 재요청을 시작합니다.
- 데이터 업데이트가 빈번한 경우엔 폴링에 비해 성능상 이점이 크지 않습니다.
3. 스트리밍(Streaming) 방식:
- 서버는 지속적인 업데이트를 위해 무한정(또는 일정 시간 동안) 요청을 대기시키며, "chunked" 기반 메시지를 이용하여 응답 시 연결을 유지 시킵니다.
- COMET을 이용한 웹 채팅 만들기:
http://hoons.kr/Lecture/LectureMain.aspx?BoardIdx=38734&kind=11&view=0
정리:
결국, COMET 방식은 데이터 전송 과정(요청/응답)에서 불필요한 많은 양의 네트웍 오버 헤더를 발생 시키며, 연결(HTTP 요청) 대기 시간에 따른 성능 저하도 추가로 발생합니다.
또한, 단방향(반이중 통신)통신인 HTTP 방식을 양방향 통신(이중 통신)으로 구현하기 위한 별도의 복잡한 개발 비용도 발생합니다.

HTML5 WebSocket:
- 이전 HTTP 통신과는 달리 클라이언트와 서버 간 양방향 통신이 가능하며, 이때 네트웍상의 메시지는 0X00바이트로 시작해서 0xFF 바이트로 끝나고 그 사이에는 UTF-8 데이터가 채워지게 됩니다.
- 아래는 폴링(Polling) 방식과 WebSocket 방식의 불필요한 네트워크 오버헤드를 비교한 결과입니다.
1. 폴링 방식:
- HTTP 요청/응답 시마다 아래와 같은 HTTP 헤더 데이터들이 전달되며, 그에 따른 네트웍 오버헤드가 발생한다.
2. WebSocket 방식:
- WebSocket 방식은 HTTP 방식과 달리 불필요한 요청/응답 헤더 데이터가 존재하지 않습니다.
3. 네트워크 오버헤드 비교:
폴링(Polling) 방식:
요청/응답 헤더 데이터 용량: (871 Byte)
1. 1000명 *  헤더 데이터 용량  = 871,000  Byte
2. 10000명 *  헤더 데이터 용량  = 8,710,000  Byte
3. 100000명 *  헤더 데이터 용량  = 87,100,000 Byte
WebSocket 방식:
메시지 데이터 용량: (2 Byte)
1. 1000명 *   메시지 데이터 용량   = 2,000  Byte
2. 10000명 *   메시지 데이터 용량   = 20,000  Byte
3. 100000명 *   메시지 데이터 용량   = 200,000 Byte
테스트 결과:
위 테스트 결과처럼 폴링 방식 데이터(위의 경우 header 데이터만 있으며, Body가 빠진상태)처리는 
WebSocket 처리 방식보다 주고 받는 데이터양에 의해 상당한 네트워크 오버헤드가 발생합니다.















4. 전송 대기시간 비교:





폴링(Polling) 방식:



서버 응답 후 요청에 대한 대기시간이 추가로 발생합니다.



즉, 클라이언트 요청부터 서버 응답까지 50ms 걸렸으며, 서버 응답 후 재요청을 만들기 위한 추가적인 대기시간이 걸립니다.







WebSocket 방식:



최초 서버와 연결 후, 연결이 그대로 유지되므로 클라이언트가 재요청을 보낼 필요가 없습니다. 



즉 추가적인 대기시간이 발생하지 않습니다.





테스트 결과:



위 테스트 결과처럼 연결이 유지되는 WebScoket 방식과는 달리 폴링 방식은 매번 일어나는 요청/응답으로 인해 대기 시간이 추가됩니다.















- 클라이언트 코드:



var WScoket = (function (win, doc) {
 
    var ua = window.navigator.userAgent.toLowerCase();
 
    return function (opt) {
 
        function init() {
 
            this.options = {
 
                socket: null,
 
                url: '',
                onopen: function () { ; },
                onmessage: function () { ; },
                onclose: function () { ; },
                onerror: function () { ; }
            };
 
            extend.call(this.options, opt);
 
            window.WebSocket && start.call(this.options);
 
            return this;
        };
 
        init.prototype = {
            send: send
        }
 
        return new init();
    }
 
    function start() {
 
        this.socket = new WebSocket(this.url);
        appendEvents.call(this, this.socket);
    }
 
    function appendEvents(socket) {
 
        var that = this;
 
        bind(socket, 'open', function (e) { that.onopen.call(socket, e); });
        bind(socket, 'message', function (e) { that.onmessage.call(socket, e); });
        bind(socket, 'close', function (e) { that.onclose.call(socket, e); });
        bind(socket, 'error', function (e) { that.onerror.call(socket, e); });
    }
 
    function send(msg) {
        this.options.socket.send(msg);
    }
 
    // 객체 상속 함수
    function extend() {
 
        var target = this
        , opts = []
        , src = null
        , copy = null;
 
        for (var i = 0, length = arguments.length; i < length; i++) {
 
            opts = arguments[i];
 
            for (var n in opts) {
                src = target[n];
                copy = opts[n];
 
                if (src === copy) continue;
                if (copy) target[n] = copy;
            }
        }
    };
 
})(window, document);
 
function webScoket()
{
    ws = WScoket({
        url: 'ws://echo.websocket.org/',
        onopen: function (e) {
            alert(this);
            alert(e);
        },
        onmessage: function (e) {
            alert(e.data);
        },
        onclose: function (e) {
            alert('close');
        },
        onerror: function (e) {
            alert('error');
        }
    });
};
 
bind(window, 'load', webScoket);
 
// 이벤트 할당
function bind(elem, type, handler, capture) {
    type = typeof type === 'string' && type || '';
    handler = handler || function () { ; };
 
    if (elem.addEventListener) {
        elem.addEventListener(type, handler, capture);
    }
    else if (elem.attachEvent) {
        elem.attachEvent('on' + type, handler);
    }
 
    return elem;
};






- 서버코드:



서버를 구현하는 코드 예제는 상당히 복잡하므로 아래 링크의 테스트 서버로 대체합니다.